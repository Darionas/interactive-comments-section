Observations and Recommendations:
Repeated Code for Comments and Replies:

The logic for handling comments and replies is almost identical in many places, leading to redundancy.
Consider creating reusable helper functions for:
Generating HTML for comments/replies.
Handling editing, replying, and deleting.
Dynamic DOM Manipulations:

Functions like insertAdjacentHTML directly manipulate the DOM repetitively. While effective, it can lead to performance bottlenecks if the dataset grows.
Use a templating library (like Handlebars or a modern framework) to handle dynamic DOM updates more efficiently.
Event Delegation:

You are attaching event listeners to dynamically generated elements (.reply__reply, .edit, .del). This can be fragile since it depends on when the DOM nodes exist.
Use event delegation:
javascript
Copy code
document.querySelector('.main__comments-section').addEventListener('click', (event) => {
    if (event.target.matches('.reply__reply')) {
        newReplyConstruct(event);
    }
    // Handle other events similarly
});
Error Handling:

Add checks for null or undefined objects (e.g., item.user, item.user.image) to prevent runtime errors.
Example:
javascript
Copy code
if (!item.user || !item.user.image) {
    console.error("Missing user or image data", item);
    return;
}
Contenteditable Management:

Using contenteditable for editing comments is fine, but:
Ensure validation (e.g., no empty comments).
Limit HTML injection by sanitizing the input.
Use libraries like DOMPurify to sanitize user inputs.
CSS Class Manipulations:

Instead of directly manipulating classes (like adding and removing .pointTo__element), consider toggling classes dynamically:
javascript
Copy code
element.classList.toggle('class-name');
Local Storage Usage:

Ensure robust handling when reading/writing to localStorage. Check if data exists and is properly structured:
javascript
Copy code
const storedData = localStorage.getItem('data');
let data = storedData ? JSON.parse(storedData) : { comments: [] };
General Formatting:

Use consistent indentation for better readability.
Extract repeated values into variables (e.g., comment__header, comment__editor) to avoid duplication.
Function Overloading:

Functions like exec are quite long and do multiple things. Break it down into smaller, single-purpose functions for readability and maintainability.
Example Refactoring for Comments/Replies Rendering:
javascript
Copy code
function renderComment(item, isReply = false) {
    const { id, content, createdAt, score, user, replies } = item;
    const youTag = user.username === currentUser.username ? `<span class="header-owner">you</span>` : '';
    const editorActions = user.username === currentUser.username
        ? `<div class="editor">
               <div class="delete del">Delete</div>
               <div class="edit edit">Edit</div>
           </div>`
        : `<div class="editor">
               <div class="reply">Reply</div>
           </div>`;

    return `
        <div class='${isReply ? 'reply' : 'comment'}' id='${id}'>
            <div class="header">
                <img src="${user.image.png}" alt="${user.username}" />
                <span>${user.username}</span>
                ${youTag}
                <span>${createdAt}</span>
            </div>
            <div class="content">${content}</div>
            <div class="vote">
                <span class="vote-plus">+</span>
                <span>${score}</span>
                <span class="vote-minus">-</span>
            </div>
            ${editorActions}
        </div>
    `.trim();
}
Event Listener Improvements:
javascript
Copy code
document.querySelector('.main__comments-section').addEventListener('click', (event) => {
    if (event.target.matches('.edit')) {
        handleEdit(event);
    } else if (event.target.matches('.del')) {
        handleDelete(event);
    } else if (event.target.matches('.reply')) {
        handleReply(event);
    }
});
Summary:
Refactoring your code for modularity, readability, and performance will ensure better maintainability and fewer bugs. Focus on:

Breaking down large functions.
Reusing common logic for comments and replies.
Leveraging event delegation and templating.